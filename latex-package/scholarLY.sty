\ProvidesPackage{scholarLY}

\RequirePackage{ifthen}
\RequirePackage{enumitem}
\RequirePackage{xstring}
\RequirePackage{keyval}
\RequirePackage{stringstrings}
\RequirePackage{verbatim}% for comments
\RequirePackage{titlecaps}% for custom names


\begin{comment}
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
compiles with:
\pdflatex? YES
\lualatex? YES
\xelatex?

% TODO:
- consider reorganizing package structure (this file master, with subfiles)
- itemization should be optional, not madatory
  . perhaps the environment around \input{file.inp} should be left open, and the
  . 'item{}' prewritten, but prepared (as a toggle, if possible) for the user.
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OPTIONS ... the customizable part of the package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
%% ~ ~ ~ GLOBAL STYLING OPTIONS ~
% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% default styles:
\def\annType{}
\def\annMeasure{}
\def\annBeat{}
\def\annVoice{}
\def\annAffected{}
\def\annMessage{}
\def\annMessageO{}
\def\annMessageOO{}

% `annStyles` keys to update styles:
\define@key{annStyles}{type}{\def\annType{#1}}
\define@key{annStyles}{measure}{\def\annMeasure{#1}}
\define@key{annStyles}{beat}{\def\annBeat{#1}}
\define@key{annStyles}{voice}{\def\annVoice{#1}}
\define@key{annStyles}{affected}{\def\annAffected{#1}}
\define@key{annStyles}{message}{\def\annMessage{#1}}
\define@key{annStyles}{message-2nd}{\def\annMessageO{#1}}
\define@key{annStyles}{message-3rd}{\def\annMessageOO{#1}}


% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
%% ~ ~ ~ DRAFT or FINAL MODE, and styling therein ~
% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% create custom settings for `draft` mode:
\newcommand{\customdraft}{}
\newcommand\setcustomdraft[1]{\renewcommand{\customdraft}{#1}}
  \setcustomdraft{
    \styleAnnMessage{##1}
  } % the default settings for DRAFT mode = nothing

\def\customdraftornot{}
\newcommand{\usecustomdraft}{\def\customdraftornot{\customdraft}}


% create custom settings for `final` mode:
\newcommand{\customfinal}{}
\newcommand\setcustomfinal[1]{\renewcommand{\customfinal}{#1}}

\def\customfinalornot{}
\newcommand{\usecustomfinal}{\def\customfinalornot{\customfinal}} % apply custom

% let custom final settings carry over to draft mode:
\newcommand{\finalfordraft}{\renewcommand{\customdraft}{\customfinal}}

% break annotations or not:
\newcommand{\letAnnBreakornot}{\par\nobreak} % default = no break
\newcommand{\annBreakAllow}{\renewcommand{\letAnnBreakornot}{\par}} % let break
\newcommand{\annBreakAvoid}{\renewcommand{\letAnnBreakornot}{\par\nobreak}} % avoid break
%
% NOTE If \enumoptions (see below) specifies vertical spacing within items, \letAnnBreak
%      is more likely to result in breaks. Otherwise, LaTeX will try to avoid breaking
%      even with \annBreakAllow employed.

% apply any of the usual enumerate arguments to the list:
\newcommand{\enumOptions}{}
\newcommand{\setEnumOptions}[1]{\renewcommand{\enumOptions}{#1}}

% inline or stacked annotations:
\newcommand{\skipornot}{}
\newcommand{\typeSkipornot}{}

\newcommand{\annInline}{%
  \renewcommand{\skipornot}{, }
  \renewcommand{\typeSkipornot}{}
}

\newcommand{\annStacked}{%
  \renewcommand{\skipornot}{\letAnnBreakornot}
  \renewcommand{\typeSkipornot}{\letAnnBreakornot}
}

% custom type name . stub
\define@key{scholarLYannotations}{type}{\def\lytype{#1}}

\def\prependType{}% stub
\def\appendType{}% stub
\def\annType{}% stub

% hide or show annotation types:
\newcommand{\annHideType}{%
  \def\CRname{}
  \def\MIname{}
  \def\LIname{}
  \def\Qname{}
  \def\TDname{}
  \def\customName{}
  \renewcommand{\typeSkipornot}{}
}
\newcommand{\annShowType}{%
  \def\CRname{{\annType\annTypeName }}
  \def\MIname{{\annType\annTypeName }}
  \def\LIname{\annType{\annTypeName }}
  \def\Qname{\annType{\annTypeName }}
  \def\TDname{\annType{\annTypeName }}
  \def\customName{\annType{\annTypeName }}
  \ifthenelse{\equal{\skipornot}{\letAnnBreakornot}}% (if stacked params)
    {\renewcommand{\typeSkipornot}{\letAnnBreakornot}}
    {\renewcommand{\typeSkipornot}{}}
}


\newcommand{\annStyleMode}{}

% declare draft/final options:
\newif\ifex@draft % (implicitly final) ... i.e. draft mode if set, otherwise final mode,
                  % which can also be explicitly set: \usepackage[final]{scholarLY}

\DeclareOption{draft}{\ex@drafttrue}
\DeclareOption{final}{\ex@draftfalse}
\ProcessOptions*

\ifex@draft
  \annStacked % default, can be overwritten in custom or global settings
  \def\CRname{\annType{\annTypeName }}
  \def\MIname{\annType{\annTypeName }}
  \def\LIname{\annType{\annTypeName }}
  \def\Qname{\annType{\annTypeName }}
  \def\TDname{\annType{\annTypeName }}
  \def\customName{\annType{\annTypeName }}
  \renewcommand{\annStyleMode}{\customdraftornot}% must be *last*
\else
  \annInline % default, can be overwritten in custom or global settings
  \def\CRname{}
  \def\MIname{}
  \def\LIname{}
  \def\Qname{}
  \def\TDname{}
  \def\customName{}
  \renewcommand{\annStyleMode}{\customfinalornot}% must be *last*
\fi


%% ~ ~ ~ ADDITIONAL CUSTOMIZATIONS ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% do something immediately after the type (only effective if type present)
\def\annPostType{}
\define@key{annPrefixes}{post-type}{\def\annPostType{#1}}
% for example, could be used to add vspace, hspace, characters, etc. after type

% do something immediately before each type or arg (arg presently affects all):
\def\annTypePrePrefix{}
\define@key{annPrefixes}{pre-type}{\def\annTypePrePrefix{#1}}
\def\annArgsPrePrefix{}
\define@key{annPrefixes}{pre-args}{\def\annArgsPrePrefix{#1}}

% first message wrapper (goes inside ann-footnote)
\def\prependMessage{}
\def\appendMessage{}
%
\newcommand\annMessageWrap[1]{
  \noexpandarg\IfSubStr{#1}{/}
    {\def\prependMessage{\StrBefore{#1}{/}}
    \def\appendMessage{\StrBehind{#1}{/}}}
    {\def\prependMessage{#1}
    \def\appendMessage{#1}}
}

% complete message wrapper
\def\prependMessageFirst{}
\def\appendMessageLast{}
%
\newcommand\annMessageWrapOuter[1]{
  \IfSubStr{#1}{/}
    {\def\prependMessageFirst{\StrBefore{#1}{/}}
    \def\appendMessageLast{\StrBehind{#1}{/}}}
    {\def\prependMessageFirst{#1}
    \def\appendMessageLast{#1}}
}

% ann type wrapper
\def\prependType{}
\def\appendType{}
%
\newcommand\annTypeWrap[1]{
  \IfSubStr{#1}{/}
    {\def\prependType{\StrBefore{#1}{/}}
    \def\appendType{\StrBehind{#1}{/}}}
    {\def\prependType{#1}
    \def\appendType{#1}}
}

%% ~ ~ ~ \annotations = the main command ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

\newcommand{\annotations}[1]
{\begin{enumerate}[mode=boxed]\enumOptions\annStyleMode\input{#1}\end{enumerate}}
%
% ex: \annotations{annotate.annotations.inp}


%% ~ ~ ~ KEY / VALUE arguments ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% keys originally set in arg 1, exported from lilypond
\define@key{scholarLYannotations}{grob}{\edef\lygrob{\detokenize{#1}}}
\define@key{scholarLYannotations}{grob-location}{\edef\lygroblocation{\detokenize{#1}}}
\define@key{scholarLYannotations}{grob-type}{\def\lygrobtype{#1}}
\define@key{scholarLYannotations}{input-file-name}{\def\lyinputfilename{#1}}
\define@key{scholarLYannotations}{context-id}{\def\lycontextid{#1}}
\define@key{scholarLYannotations}{location}{\edef\lylocation{\detokenize{#1}}}
\define@key{scholarLYannotations}{message}{\def\lymessage{#1}}
\define@key{scholarLYannotations}{type}{\def\lyanntype{#1}}
\define@key{scholarLYannotations}{context}{\def\lycontext{#1}}
\define@key{scholarLYannotations}{ann-footnote}{\def\lyannfootnote{#1}}

\def\resetkeys{
  \setkeys{scholarLYannotations}{% default values
    grob = no value given,
    grob-location = no value given,
    grob-type = no value given,
    input-file-name = no value given,
    context-id = no value given,
    location = no value given,
    type = no value given,
    message = no value given,
    context = no value given,
    ann-footnote = {no value given}
  }
}

\def\noMessError{\color{red} Oops! No message has been entered for this annotation.}


% default Prefixes
\def\annGrobPrx{}
\def\annGrobLocationPfx{}
\def\annGrobTypePfx{}
\def\lyinputfilenamePfx{}
\def\lycontextidPfx{}
\def\annLocationPfx{}
\def\annTypePfx{}
\def\annMessagePfx{}
\def\annContextPfx{}
\def\annMeasurePfx{M.}
\def\annBeatPfx{beat }

% key family/names for overrides
\define@key{annPrefixes}{grob}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{grob-location}{\def\annGrobLocationPfx{#1}}
\define@key{annPrefixes}{grob-type}{\def\annGrobTypePfx{#1}}
\define@key{annPrefixes}{input-file-name}{\def\annInputFileNamePfx{#1}}
\define@key{annPrefixes}{context-id}{\def\annContextIDPfx{#1}}
\define@key{annPrefixes}{location}{\def\annLocationPfx{#1}}
\define@key{annPrefixes}{type}{\def\annTypePfx{#1}}
\define@key{annPrefixes}{message}{\def\annMessagePfx{#1}}
\define@key{annPrefixes}{context}{\def\annContextPfx{#1}}
\define@key{annPrefixes}{measure}{\def\annMeasurePfx{#1}}
\define@key{annPrefixes}{beat}{\def\annBeatPfx{#1}}


% if same measure, optionally substitute:
\def\previousMeasure{0}
\def\sameMeasureStub{---}
\define@key{annExtras}{same-measure}{\def\sameMeasureStub{#1}}
\def\sameMeasure{\sameMeasureStub}% NOTE this isn't a redundancy (see below - it's a default)
\def\currentMeasure{0}
% \verboseMeasures = makes measures always show; TODO discuss the name
\newcommand{\annVerboseMeasures}{\def\sameMeasure{\annMeasurePfx\currentMeasure,}}

% optionally substitute same beat (if *also* same measure)
\def\previousBeat{0}
\def\sameBeatStub{{---}\unskip}
\define@key{annExtras}{same-beat}{\def\sameBeatStub{#1}}
\def\sameBeat{\sameBeatStub}% NOTE this isn't a redundancy (see below - it's a default)
\def\currentBeat{0}
% \verboseBeats
\newcommand{\annVerboseBeats}{\def\sameBeat{\annBeatPfx\currentBeat}}


\ifthenelse{\equal{\sameMeasure}{\annMeasurePfx\currentMeasure,}}% if verbose measures
  %true
  {\ifthenelse{\equal{\currentBeat}{\previousBeat}}% if current beat = previous beat
    %true
    {\ifthenelse{\equal{\sameBeat}{\annBeatPfx\currentBeat}}% if verbose beats
      %true
      {\def\sameBeat{\currentBeat}}% then, beats always = current beat
      %false
      {\def\sameBeat{\sameBeatStub}}}% else, same beats = stub
    %false
    {}}% do nothing.. current beat displayed always
  %false
  {}% else nothing


%% ~ ~ ~ the PARSERS ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

%
%%
%%%%
%%%%%
% FOOTNOTES

%determine if there are custom footnotes, by searching arg #1
% (\bigmessage is defined by arg #1 for each annotation)
\def\customFootsParse{
  \StrCount{\bigmessage}{-text=}[\howmanytext]
  \StrCount{\bigmessage}{ann-footnote=}[\howmanyannfn]
  % IF how many ann-footnote = 0
  \ifthenelse{\equal{\howmanyannfn}{0}}{
    \ifthenelse{\equal{\howmanytext}{0}}
      % yes, creat redundant (empty) defs, for testing; remove later
      {
      \def\resultOne{}
      \def\resultTwo{}
      \def\resultThree{}
      \def\resultFour{}
      \def\resultFive{}
      }
      % no
      {\ifthenelse{\equal{\howmanytext}{1}}
        % yes...
        {%
        \StrBehind[1]{\bigmessage}{-text=}[\resultOne]
        \def\resultTwo{}
        \def\resultThree{}
        \def\resultFour{}
        \def\resultFive{}
        }
        % no
        {\ifthenelse{\equal{\howmanytext}{2}}
          % yes
          {%
          \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
            \StrGobbleRight{\resultOne}{2}[\resultOne]
          \StrBehind[2]{\bigmessage}{-text=}[\resultTwo]
          \def\resultThree{}
          \def\resultFour{}
          \def\resultFive{}
          }
          % no
          {\ifthenelse{\equal{\howmanytext}{3}}
            % yes
            {%
            \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
              \StrGobbleRight{\resultOne}{2}[\resultOne]% removes comma
            \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
              \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
            \StrBehind[3]{\bigmessage}{-text=}[\resultThree]
            \def\resultFour{}
            \def\resultFive{}
            }
            % no
            {\ifthenelse{\equal{\howmanytext}{4}}
              % yes
              {%
              \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
                \StrGobbleRight{\resultOne}{2}[\resultOne]% removes comma
              \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
                \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
              \StrBetween[3,4]{\bigmessage}{-text=}{fn-}[\resultThree]
                \StrGobbleRight{\resultThree}{2}[\resultThree]% same...
              \StrBehind[4]{\bigmessage}{-text=}[\resultFour]
              \def\resultFive{}
              }
              % no
              {\ifthenelse{\equal{\howmanytext}{5}}
                % yes
                {%
                \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
                  \StrGobbleRight{\resultOne}{2}[\resultOne]% same...
                \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
                  \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
                \StrBetween[3,4]{\bigmessage}{-text=}{fn-}[\resultThree]
                  \StrGobbleRight{\resultThree}{2}[\resultThree]% same...
                \StrBetween[4,5]{\bigmessage}{-text=}{fn-}[\resultFour]
                  \StrGobbleRight{\resultFour}{2}[\resultFour]% same...
                \StrBehind[5]{\bigmessage}{-text=}[\resultFive]
                }
                % no
                {}% stop here? yes while it is only in proof stage
              }
            }
          }
        }
      }
    }
    % else... there IS an ann-footnote
    {\ifthenelse{\equal{\howmanytext}{0}}
      % yes
      {%
      \def\resultOne{}
      \def\resultTwo{}
      \def\resultThree{}
      \def\resultFour{}
      \def\resultFive{}
      }
      % no
      {\ifthenelse{\equal{\howmanytext}{1}}
        % yes
        {%
        \StrBetween[1,1]{\bigmessage}{-text=}{, ann-footnote}[\resultOne]
        \def\resultTwo{}
        \def\resultThree{}
        \def\resultFour{}
        \def\resultFive{}
        }
        % no
        {\ifthenelse{\equal{\howmanytext}{2}}
          % yes
          {%
          \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
          \StrBetween[2,1]{\bigmessage}{-text=}{ann-footnote}[\resultTwo]
          \def\resultThree{}
          \def\resultFour{}
          \def\resultFive{}
          }
          % no
          {\ifthenelse{\equal{\howmanytext}{3}}
            % yes
            {%
            \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
            \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
            \StrBetween[3,1]{\bigmessage}{-text=}{ ann-footnote}[\resultThree]
            \def\resultFour{}
            \def\resultFive{}
            }
            % no
            {\ifthenelse{\equal{\howmanytext}{4}}
              % yes
              {%
              \StrBetween[1,2]{\bigmessage}{-text=}{, fn-}[\resultOne]
              \StrBetween[2,3]{\bigmessage}{-text=}{, fn-}[\resultTwo]
              \StrBetween[3,4]{\bigmessage}{-text=}{, fn-}[\resultThree]
              \StrBetween[4,1]{\bigmessage}{-text=}{, ann-footnote}[\resultFour]
              \def\resultFive{}
              }
              % no
              {\ifthenelse{\equal{\howmanytext}{5}}
                % yes
                {%
                \StrBetween[1,2]{\bigmessage}{-text=}{, fn-}[\resultOne]
                \StrBetween[2,3]{\bigmessage}{-text=}{, fn-}[\resultTwo]
                \StrBetween[3,4]{\bigmessage}{-text=}{, fn-}[\resultThree]
                \StrBetween[4,5]{\bigmessage}{-text=}{, fn-}[\resultFour]
                \StrBetween[5,1]{\bigmessage}{-text=}{, ann-footnote}[\resultFive]
                }
                % no
                {%
                \def\resultOne{}
                \def\resultTwo{}
                \def\resultThree{}
                \def\resultFour{}
                \def\resultFive{}
                }% stop here? yes while it is only in proof stage...
              }
            }
          }
        }
      }
    }
}


% define the macro names for custom footnotes:

\def\extractFNnames{%
  \expandarg\StrCount{\bigmessage}{fn-}[\theFNnum]
  \ifthenelse{\equal{\theFNnum}{0}}
    {%
    \def\resultOneMacro{}
    \def\resultTwoMacro{}
    \def\resultThreeMacro{}
    \def\resultFourMacro{}
    \def\resultFiveMacro{}
    }% don't make any macro names
    {\ifthenelse{\equal{\theFNnum}{1}}
      {%
      \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
        \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
      \def\resultTwoMacro{}
      \def\resultThreeMacro{}
      \def\resultFourMacro{}
      \def\resultFiveMacro{}
      }
      {\ifthenelse{\equal{\theFNnum}{2}}
        {%
        \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
          \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
        \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
          \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
        \def\resultThreeMacro{}
        \def\resultFourMacro{}
        \def\resultFiveMacro{}
        }
        {\ifthenelse{\equal{\theFNnum}{3}}
          {%
          \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
            \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
          \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
            \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
          \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
            \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
          \def\resultFourMacro{}
          \def\resultFiveMacro{}
          }
          {\ifthenelse{\equal{\theFNnum}{4}}
            {%
            \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
              \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
            \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
              \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
            \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
              \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
            \StrBetween[4,4]{\bigmessage}{fn-}{-text=}[\resultFourMacro]
              \StrDel{\resultFourMacro}{-}[\resultFourMacro]% remove hyphens
            \def\resultFiveMacro{}
            }
            {\ifthenelse{\equal{\theFNnum}{5}}
              {%
              \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
                \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
              \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
                \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
              \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
                \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
              \StrBetween[4,4]{\bigmessage}{fn-}{-text=}[\resultFourMacro]
                \StrDel{\resultFourMacro}{-}[\resultFourMacro]% remove hyphens
              \StrBetween[5,5]{\bigmessage}{fn-}{-text=}[\resultFiveMacro]
                \StrDel{\resultFiveMacro}{-}[\resultFiveMacro]% remove hyphens
              }
              {there must be too many}% NOTE this is a STUB
            }
          }
        }
      }
    }
}



% create the macros that are used in the messages:

\def\makeFNmacros{
  \ifthenelse{\equal{\theFNnum}{0}}
    {}% don't make any macros
    {\ifthenelse{\equal{\theFNnum}{1}}
      % yes
      {%
      \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
      }
      % no
      {\ifthenelse{\equal{\theFNnum}{2}}
        % yes
        {%
        \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
        \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }
        }
        % no
        {\ifthenelse{\equal{\theFNnum}{3}}
          % yes
          {%
          \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
          \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }
          \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
          }
          % no
          {\ifthenelse{\equal{\theFNnum}{4}}
            % yes
            {%
            \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
            \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }        \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
            \expandafter\def\csname fn\resultFourMacro\endcsname{\footnote{\resultFour} }
            }
            % no
            {\ifthenelse{\equal{\theFNnum}{5}}
              % yes
              {%
              \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
              \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }        \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
              \expandafter\def\csname fn\resultFourMacro\endcsname{\footnote{\resultFour} }
              \expandafter\def\csname fn\resultFiveMacro\endcsname{\footnote{\resultFive} }
              }
              % no
              {}%stop here? yes, while it is only in proof stage
            }
          }
        }
      }
    }
}



%
%%
%%%%
%%%%%
% MESSAGES

% test the message for punctuations, and store the result:

\def\annMessagePunct{}% default, no punctuation

\newcommand{\testMessagePunct}{%
  %\saveexpandmode\expandarg
    \IfEndWith{\lymessage}{.}
      % true
      {\def\annMessagePunct{.}}
      % false
      {\IfEndWith{\lymessage}{?}
        % true
        {\def\annMessagePunct{?}}
        % false
        {\IfEndWith{\lymessage}{!}
          % true
          {\def\annMessagePunct{!}}
          % false
          {\def\annMessagePunct{\unskip}}
        }
      }
  %\restoreexpandmode
}


% parse messages:
% TODO unskip ONLY if prependMessage is NOT equal to {}? Make user set that?
\newcommand{\annMessageParse}{%
  %\saveexpandmode\expandarg
    \IfEndWith{\lymessage}{.}
      % true; the user set a period for punctuation
      {%
      \StrGobbleRight{\lymessage}{1}[\lymessage]
        \annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak
      }
      % false
      {\IfEndWith{\lymessage}{?}
        % true; the user set a question mark for punctuation
        {%
        \StrGobbleRight{\lymessage}{1}[\lymessage]
          \annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak
        }
        % false
        {\IfEndWith{\lymessage}{!}
          % true; the user set an exclamation point for punctuation
          {%
          \StrGobbleRight{\lymessage}{1}[\lymessage]
            \annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak
          }
          % false
          {\ifthenelse{\equal{\lymessage}{no value given}}{\unskip\noMessError}
            % else
            {\ifthenelse{\equal{\lymessage}{}}{\unskip\noMessError}
              % else
              {\annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak}}}
        }
      }
  %\restoreexpandmode
}


% set the append/punct vs. punct/append orientations:
\newcommand{\annMessTail}{\annMessageOO{\annMessageO{\annMessage\annMessagePunct\appendMessage}}} % default = Punct, Append

% user command, set order: punct, append
\newcommand{\annMessPunctAppend}{%
  \renewcommand{\annMessTail}{\annMessageOO{\annMessageO{\annMessage\annMessagePunct\unskip\appendMessage}}}}
% set order: append, punct
\newcommand{\annMessAppendPunct}{%
  \renewcommand{\annMessTail}{\annMessageOO{\annMessageO{\annMessage\appendMessage\unskip\annMessagePunct}}}}


% get type from key
\def\annTypeName{%
  \StrSubstitute{\lyanntype}{-}{ }[\annTypeCleaned]
  \prependType\titlecap{\annTypeCleaned}\appendType
}


%
%%
%%%%
%%%%%
% ANNOTATIONS

% default annotation parsers: for stacked and inline modes that can be easily
% hacked/reconfigured to custom designs.

\let\KV@errx@ORI\KV@errx% store original error handling

% critical remark:
\newcommand{\criticalRemark}[5][]{%
  % set KEYS, defaults, then new from #1
    \resetkeys
      \let\KV@errx\@gobble% ignore unknown keys
      \setkeys{scholarLYannotations}{#1}
      \let\KV@errx\KV@errx@ORI% Restore original error handling
  \saveexpandmode\expandarg
  % PARSE FOOTNOTES
    \def\bigmessage{#1}% used in fn 1, 2, 3
      \customFootsParse% parse fn, step one
      \extractFNnames% parse fn, step two
      \makeFNmacros% parse fn, step three
  % TEST MESSAGE PUNCTUATION; DEFINE measure and beat
    \testMessagePunct
    \def\currentMeasure{#2}
    \def\currentBeat{#3}
  % APPLY to ITEM
    \item{
      \annTypePrePrefix\annTypePfx\CRname\annPostType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annArgsPrePrefix\annLocationPfx{\annMeasure{\sameMeasure}}}
        {\annArgsPrePrefix\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\annArgsPrePrefix\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\annArgsPrePrefix\annGrobTypePfx\annAffected{#5}\skipornot}
      \annArgsPrePrefix\annMessagePfx{{{%
        \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
    % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


% musical issue:
\newcommand{\musicalIssue}[5][]{%
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
    \annTypePrePrefix\annTypePfx\MIname\annPostType\typeSkipornot
    \ifthenelse{\equal{#2}{\previousMeasure}}{\annArgsPrePrefix\annLocationPfx{\annMeasure{\sameMeasure}}}
      {\annArgsPrePrefix\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
    \ifthenelse{\equal{#2}{\previousMeasure}}
      {\ifthenelse{\equal{#3}{}}{\unskip{}}
        {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
          {\annBeat{\annBeatPfx#3}\skipornot}}}
      {\annBeat{\annBeatPfx#3}\skipornot}
    \ifthenelse{\equal{#4}{}}{\unskip{}}
      {\annArgsPrePrefix\annContextPfx\annVoice{#4}\skipornot}
    \ifthenelse{\equal{#5}{}}{\unskip{}}
      {\annArgsPrePrefix\annGrobTypePfx\annAffected{#5}\skipornot}
    \annArgsPrePrefix\annMessagePfx{{{%
      \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
    \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
      {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
  \def\previousMeasure{#2}
  \def\previousBeat{#3}
}


% lilypond issue:
\newcommand{\lilypondIssue}[5][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
    \annTypePrePrefix\annTypePfx\LIname\annPostType\typeSkipornot
    \ifthenelse{\equal{#2}{\previousMeasure}}{\annArgsPrePrefix\annLocationPfx{\annMeasure{\sameMeasure}}}
      {\annArgsPrePrefix\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
    \ifthenelse{\equal{#2}{\previousMeasure}}
      {\ifthenelse{\equal{#3}{}}{\unskip{}}
        {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
          {\annBeat{\annBeatPfx#3}\skipornot}}}
      {\annBeat{\annBeatPfx#3}\skipornot}
    \ifthenelse{\equal{#4}{}}{\unskip{}}
      {\annArgsPrePrefix\annContextPfx\annVoice{#4}\skipornot}
    \ifthenelse{\equal{#5}{}}{\unskip{}}
      {\annArgsPrePrefix\annGrobTypePfx\annAffected{#5}\skipornot}
    \annArgsPrePrefix\annMessagePfx{{{%
      \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
    \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
      {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
  \def\previousMeasure{#2}
  \def\previousBeat{#3}
}


% question:
\newcommand{\annotateQuestion}[5][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
    \annTypePrePrefix\annTypePfx\Qname\annPostType\typeSkipornot
    \ifthenelse{\equal{#2}{\previousMeasure}}{\annArgsPrePrefix\annLocationPfx{\annMeasure{\sameMeasure}}}
      {\annArgsPrePrefix\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
    \ifthenelse{\equal{#2}{\previousMeasure}}
      {\ifthenelse{\equal{#3}{}}{\unskip{}}
        {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
          {\annBeat{\annBeatPfx#3}\skipornot}}}
      {\annBeat{\annBeatPfx#3}\skipornot}
    \ifthenelse{\equal{#4}{}}{\unskip{}}
      {\annArgsPrePrefix\annContextPfx\annVoice{#4}\skipornot}
    \ifthenelse{\equal{#5}{}}{\unskip{}}
      {\annArgsPrePrefix\annGrobTypePfx\annAffected{#5}\skipornot}
    \annArgsPrePrefix\annMessagePfx{{{%
      \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
    \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
      {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
  \def\previousMeasure{#2}
  \def\previousBeat{#3}
}


% todo:
\newcommand{\annotateTodo}[5][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
    \annTypePrePrefix\annTypePfx\TDname\annPostType\typeSkipornot
    \ifthenelse{\equal{#2}{\previousMeasure}}{\annArgsPrePrefix\annLocationPfx{\annMeasure{\sameMeasure}}}
      {\annArgsPrePrefix\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
    \ifthenelse{\equal{#2}{\previousMeasure}}
      {\ifthenelse{\equal{#3}{}}{\unskip{}}
        {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
          {\annBeat{\annBeatPfx#3}\skipornot}}}
      {\annBeat{\annBeatPfx#3}\skipornot}
    \ifthenelse{\equal{#4}{}}{\unskip{}}
      {\annArgsPrePrefix\annContextPfx\annVoice{#4}\skipornot}
    \ifthenelse{\equal{#5}{}}{\unskip{}}
      {\annArgsPrePrefix\annGrobTypePfx\annAffected{#5}\skipornot}
    \annArgsPrePrefix\annMessagePfx{{{%
      \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
    \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
      {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
  \def\previousMeasure{#2}
  \def\previousBeat{#3}
}


% generic annotations:
\newcommand{\annotation}[5][]{% generic annotation, for custom types
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
    \annTypePrePrefix\annTypePfx\TDname\annPostType\typeSkipornot
    \ifthenelse{\equal{#2}{\previousMeasure}}{\annArgsPrePrefix\annLocationPfx{\annMeasure{\sameMeasure}}}
      {\annArgsPrePrefix\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
    \ifthenelse{\equal{#2}{\previousMeasure}}
      {\ifthenelse{\equal{#3}{}}{\unskip{}}
        {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
          {\annBeat{\annBeatPfx#3}\skipornot}}}
      {\annBeat{\annBeatPfx#3}\skipornot}
    \ifthenelse{\equal{#4}{}}{\unskip{}}
      {\annArgsPrePrefix\annContextPfx\annVoice{#4}\skipornot}
    \ifthenelse{\equal{#5}{}}{\unskip{}}
      {\annArgsPrePrefix\annGrobTypePfx\annAffected{#5}\skipornot}
    \annArgsPrePrefix\annMessagePfx{{{%
      \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
    \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
      {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
  \def\previousMeasure{#2}
  \def\previousBeat{#3}
}


\begin{comment}

. . . . . . . . . . THIS FUNCTION NOT READY YET . . . . . . . . . . .

[The use of custom footnotes causes compilation to fail.
Function will be updated to handle custom footnotes soon enough.]

~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% for the entirely custom command: \useCustomAnn{ ... custom stuff ... }
% NOTE this is really just a placeholder right now..

\newcommand{\customannotations}[3]{
  \expandafter{#1}
  \input{#2}
  \expandafter{#3}
}

\newcommand\useCustomAnn[1]{
  \renewcommand\criticalRemark[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\musicalIssue[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\lilypondIssue[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotateQuestion[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotateTodo[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotation[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
}

\end{comment}

% Ignore unknown keys ... this must be last
%\makeatletter
%\let\KV@errx\@gobble
%\makeatother

\endinput
